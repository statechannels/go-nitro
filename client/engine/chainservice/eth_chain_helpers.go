package chainservice

import (
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	NitroAdjudicator "github.com/statechannels/go-nitro/client/engine/chainservice/adjudicator"
)

// getChainHolding reads on-chain holdings for a channel and an asset address given a transaction and an event generated by the transaction.
func getChainHolding(na *NitroAdjudicator.NitroAdjudicator, tx *types.Transaction, event *NitroAdjudicator.NitroAdjudicatorAllocationUpdated) (common.Address, *big.Int, error) {
	assetAddress, err := assetAddressForIndex(na, tx, event.AssetIndex)
	if err != nil {
		return assetAddress, &big.Int{}, err
	}
	amount, err := na.Holdings(&bind.CallOpts{BlockNumber: new(big.Int).SetUint64(event.Raw.BlockNumber)}, assetAddress, event.ChannelId)
	if err != nil {
		return assetAddress, amount, err
	}
	return assetAddress, amount, nil
}

// assetAddressForIndex uses the input parameters of a transaction to map an asset index to an asset address
func assetAddressForIndex(na *NitroAdjudicator.NitroAdjudicator, tx *types.Transaction, index *big.Int) (common.Address, error) {
	abi, err := NitroAdjudicator.NitroAdjudicatorMetaData.GetAbi()
	if err != nil {
		return common.Address{}, err
	}
	params, err := decodeTxParams(abi, tx.Data())
	if err != nil {
		return common.Address{}, err
	}
	// TODO remove the assumption that the tx incudes latestVariablePart parameter
	// 	concludeAndTransferAllAssets includes this parameter, but transferAllAssets, transfer, and claim do not.
	//  https://github.com/statechannels/go-nitro/issues/759
	variablePart := params["latestVariablePart"].(struct {
		Outcome []struct {
			Asset       common.Address "json:\"asset\""
			Metadata    []uint8        "json:\"metadata\""
			Allocations []struct {
				Destination    [32]uint8 "json:\"destination\""
				Amount         *big.Int  "json:\"amount\""
				AllocationType uint8     "json:\"allocationType\""
				Metadata       []uint8   "json:\"metadata\""
			} "json:\"allocations\""
		} "json:\"outcome\""
		AppData []uint8  "json:\"appData\""
		TurnNum *big.Int "json:\"turnNum\""
		IsFinal bool     "json:\"isFinal\""
	})
	return variablePart.Outcome[index.Int64()].Asset, nil

}

func decodeTxParams(abi *abi.ABI, data []byte) (map[string]interface{}, error) {
	m, err := abi.MethodById(data[:4])
	if err != nil {
		return map[string]interface{}{}, err

	}
	v := map[string]interface{}{}
	if err := m.Inputs.UnpackIntoMap(v, data[4:]); err != nil {
		return map[string]interface{}{}, err
	}

	return v, nil
}
