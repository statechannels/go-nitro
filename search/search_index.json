{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nitro Channels Nitro channels are a technology which allows for ultra-low cost, near-zero-latency conditional transfer of cryptoassets. They work by allowing users to deposit their funds into a \"layer 2\" network which sits above a blockchain. This layer 2 network inherits many of the properties of the underlying chain -- for example, permisionlessness and the lack of a need to place trust in any counterparty. The network benefits from significant advantages, however -- in a fraction of a second, a direct, private connection can be forged with anyone else in the network. Then, payments can be streamed incredibly fast: up to hundreds of times per second . What's more, there is no per-payment fee to cover (just a small fee per unit time for maintaining the connection). This is in sharp contrast to the experience of transacting publicly on a \"layer 1\" blockchain or even on a rollup chain. There, fees and latency apply to each and every action. What's on offer These docs cover the open source code at https://github.com/statechannels/go-nitro . This includes @statechannels/nitro-protocol : smart contracts and utilities . go-nitro fully-featured off-chain client libary. Inline documentation generated with godoc.","title":"Nitro Channels"},{"location":"#nitro-channels","text":"Nitro channels are a technology which allows for ultra-low cost, near-zero-latency conditional transfer of cryptoassets. They work by allowing users to deposit their funds into a \"layer 2\" network which sits above a blockchain. This layer 2 network inherits many of the properties of the underlying chain -- for example, permisionlessness and the lack of a need to place trust in any counterparty. The network benefits from significant advantages, however -- in a fraction of a second, a direct, private connection can be forged with anyone else in the network. Then, payments can be streamed incredibly fast: up to hundreds of times per second . What's more, there is no per-payment fee to cover (just a small fee per unit time for maintaining the connection). This is in sharp contrast to the experience of transacting publicly on a \"layer 1\" blockchain or even on a rollup chain. There, fees and latency apply to each and every action.","title":"Nitro Channels"},{"location":"#whats-on-offer","text":"These docs cover the open source code at https://github.com/statechannels/go-nitro . This includes @statechannels/nitro-protocol : smart contracts and utilities . go-nitro fully-featured off-chain client libary. Inline documentation generated with godoc.","title":"What's on offer"},{"location":"faqs/","text":"FAQs What is a state channel? A state channel can be thought of as an account with multiple balances (commonly just two). The owners of that account can update those balances according to some rules which they agree on beforehand and which can be enforced on a blockchain. State channels therefore allow for peer-to-peer games, payments and other few-user applications to safely trade blockchain assets at extremely low latency, low cost and high throughput without requiring trust in a third-party. What kind of applications are there? State channels can be programmed such that assets are redistributed according to arbitary logic, allowing for applications such as poker, conditional payments, atomic swaps and more. What is Nitro Protocol? Nitro protocol is a state of the art state channel protocol which is focussed on security, performance and extensibility. It has been developed over several years of research . One of the key features of Nitro are virtual channels , where peers can setup a direct connection with each other entirely off-chain. How is it implemented? The on-chain components of Nitro protocol are implemented in solidity, and are published alongside lightweight off-chain support in Typescript in the npm package @statechannels/nitro-protocol . The off-chain component of the protocol are implemented in go-nitro , a reference client for Nitro Protocol. Where is it being used? The maintainers of nitro-protocol and go-nitro are working towards integrating the system into the Filecoin Retrieval Market and the Filecoin Virtual Machine . How can I find out more? This website covers all the material you need to understand whether Nitro Protocol is a good fit for your use case. Is it a good fit for my use case? State channels are not a panacea. If you can answer \"yes\" to one or more of these questions, then they could be a good solution for your application: Do you require very low latency transactions? Do you require the cost per transaction to be extremely low or zero? Do you require some level of privacy? Alternatives Other layer 2 scaling solutions may be more appropriate for your use case.","title":"FAQs"},{"location":"faqs/#faqs","text":"","title":"FAQs"},{"location":"faqs/#what-is-a-state-channel","text":"A state channel can be thought of as an account with multiple balances (commonly just two). The owners of that account can update those balances according to some rules which they agree on beforehand and which can be enforced on a blockchain. State channels therefore allow for peer-to-peer games, payments and other few-user applications to safely trade blockchain assets at extremely low latency, low cost and high throughput without requiring trust in a third-party.","title":"What is a state channel?"},{"location":"faqs/#what-kind-of-applications-are-there","text":"State channels can be programmed such that assets are redistributed according to arbitary logic, allowing for applications such as poker, conditional payments, atomic swaps and more.","title":"What kind of applications are there?"},{"location":"faqs/#what-is-nitro-protocol","text":"Nitro protocol is a state of the art state channel protocol which is focussed on security, performance and extensibility. It has been developed over several years of research . One of the key features of Nitro are virtual channels , where peers can setup a direct connection with each other entirely off-chain.","title":"What is Nitro Protocol?"},{"location":"faqs/#how-is-it-implemented","text":"The on-chain components of Nitro protocol are implemented in solidity, and are published alongside lightweight off-chain support in Typescript in the npm package @statechannels/nitro-protocol . The off-chain component of the protocol are implemented in go-nitro , a reference client for Nitro Protocol.","title":"How is it implemented?"},{"location":"faqs/#where-is-it-being-used","text":"The maintainers of nitro-protocol and go-nitro are working towards integrating the system into the Filecoin Retrieval Market and the Filecoin Virtual Machine .","title":"Where is it being used?"},{"location":"faqs/#how-can-i-find-out-more","text":"This website covers all the material you need to understand whether Nitro Protocol is a good fit for your use case.","title":"How can I find out more?"},{"location":"faqs/#is-it-a-good-fit-for-my-use-case","text":"State channels are not a panacea. If you can answer \"yes\" to one or more of these questions, then they could be a good solution for your application: Do you require very low latency transactions? Do you require the cost per transaction to be extremely low or zero? Do you require some level of privacy?","title":"Is it a good fit for my use case?"},{"location":"faqs/#alternatives","text":"Other layer 2 scaling solutions may be more appropriate for your use case.","title":"Alternatives"},{"location":"research-papers/","text":"Research papers Nitro is based on a culmination of reserach spanning the following papers: (2018) ForceMove An n-party state channel protocol. (2019) Nitro A protocol for state channel networks. (2022) Stateful Asset Transfer Protocol A simple and scalable protocol for virtual state channel networks.","title":"Research papers"},{"location":"research-papers/#research-papers","text":"Nitro is based on a culmination of reserach spanning the following papers:","title":"Research papers"},{"location":"research-papers/#2018-forcemove","text":"An n-party state channel protocol.","title":"(2018)  ForceMove"},{"location":"research-papers/#2019-nitro","text":"A protocol for state channel networks.","title":"(2019)  Nitro"},{"location":"research-papers/#2022-stateful-asset-transfer-protocol","text":"A simple and scalable protocol for virtual state channel networks.","title":"(2022)  Stateful Asset Transfer Protocol"},{"location":"applications/0010-filecoin/","text":"Filecoin Nitro channels are currently under development for use in the Filecoin ecosystem, with support from the Filecoin Foundation . Efforts are concentrated on two main areas: Retrieval Markets Low latency payments can incentivize retrieval providers to provide files to retrieval clients, without burdening either party with slow transaction confirmation times or high transaction costs. This will faciliate a decentralized CDN for Filecoin. Filecoin Virtual Machine Filecoin is working towards having an EVM-compatible virtual machine . This is a crucial step allowing for Nitro to be implemented in solidity and deployed to Filecoin. This not only enables the retrieval markets application(s), but a whole raft of other applications looking to benefit from the same sweetness that Nitro can bring.","title":"Filecoin"},{"location":"applications/0010-filecoin/#filecoin","text":"Nitro channels are currently under development for use in the Filecoin ecosystem, with support from the Filecoin Foundation . Efforts are concentrated on two main areas:","title":"Filecoin"},{"location":"applications/0010-filecoin/#retrieval-markets","text":"Low latency payments can incentivize retrieval providers to provide files to retrieval clients, without burdening either party with slow transaction confirmation times or high transaction costs. This will faciliate a decentralized CDN for Filecoin.","title":"Retrieval Markets"},{"location":"applications/0010-filecoin/#filecoin-virtual-machine","text":"Filecoin is working towards having an EVM-compatible virtual machine . This is a crucial step allowing for Nitro to be implemented in solidity and deployed to Filecoin. This not only enables the retrieval markets application(s), but a whole raft of other applications looking to benefit from the same sweetness that Nitro can bring.","title":"Filecoin Virtual Machine"},{"location":"applications/0020-web3torrent/","text":"Web3Torrent Web3Torrent is a proof of concept state channel application powered by Nitro. It shows off the power of virtual channels by allowing seeders to earn from peers in a torrent swarm who download from them. It is built on webTorrent . To learn more, read the accompanying blog post .","title":"Web3Torrent"},{"location":"applications/0020-web3torrent/#web3torrent","text":"Web3Torrent is a proof of concept state channel application powered by Nitro. It shows off the power of virtual channels by allowing seeders to earn from peers in a torrent swarm who download from them. It is built on webTorrent . To learn more, read the accompanying blog post .","title":"Web3Torrent"},{"location":"applications/0030-others/","text":"Others In the past we built Rock Paper Scissors and Tic Tac Toe , which work with a general purpose wallet accessed through an iframe.","title":"Others"},{"location":"applications/0030-others/#others","text":"In the past we built Rock Paper Scissors and Tic Tac Toe , which work with a general purpose wallet accessed through an iframe.","title":"Others"},{"location":"protocol-tutorial/0010-states-channels/","text":"States & Channels A state channel can be thought of as a set of data structures (called \"states\") committed to and exchanged between a fixed set of actors (which we call participants), together with some execution rules. Info In Nitro, participants \"commit to\" a state by digitially signing it. A state channel controls funds which are locked up -- either on an L1 blockchain or on some other ledger such as another state channel. State channel execution may always be disputed on-chain via a contract we call the Adjudicator, although this not necessary. States In Nitro protocol, a state is broken up into fixed and variable parts: Solidity TypeScript Go import { ExitFormat as Outcome } from '@statechannels/exit-format/contracts/ExitFormat.sol' ; struct FixedPart { uint256 chainId ; address [] participants ; uint48 channelNonce ; address appDefinition ; uint48 challengeDuration ; } struct VariablePart { Outcome . SingleAssetExit [] outcome ; // (1) bytes appData ; uint48 turnNum ; bool isFinal ; } This composite type is explained in the section on outcomes . import * as ExitFormat from '@statechannels/exit-format' ; // (1) import { Address , Bytes , Bytes32 , Uint256 , Uint48 , Uint64 } from '@statechannels/nitro-protocol' ; export interface FixedPart { chainId : Uint256 ; participants : Address []; channelNonce : Uint64 ; appDefinition : Address ; challengeDuration : Uint48 ; } export interface VariablePart { outcome : ExitFormat.Exit ; // (2) appData : Bytes ; turnNum : Uint48 ; isFinal : boolean ; } Bytes32 , Bytes , Address , Uint256 , Uint64 are aliases to the Javascript string type. They are respresented as hex strings. Uint48 is aliased to a number . This composite type is explained in the section on outcomes . import ( \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" // (1) ) type ( FixedPart struct { ChainId * types . Uint256 Participants [] types . Address ChannelNonce uint64 AppDefinition types . Address ChallengeDuration uint32 } VariablePart struct { AppData types . Bytes Outcome outcome . Exit // (2) TurnNum uint64 IsFinal bool } ) types.Address is an alias to go-ethereum's common.Address type. types.Bytes32 is an alias to go-ethereum's common.Hash type. This composite type is explained in the section on outcomes . Info States are usually submitted to the blockchain as a single fixed part and multiple (signed) variable parts. This is known as a \"support proof\" . Let's take each property in turn: Fixed Part Chain id This needs to match the id of the chain where assets are to be locked (i.e. the 'root' of the funding graph for this channel). In the event of a mismatch, the channel cannot be concluded and funds cannot be unlocked. Participants This is a list of Ethereum addresses, each derived from an ECDSA private key in the usual manner. Each address represents a participant in the state channel who is able to commit to state updates and thereby cause the channel to finalize on chain. Warning Before joining a state channel, you (or your off-chain software) should check that it has length at least 2, but no more than 255, and include a public key (account) that you control. Each entry should be a nonzero ethereum address. ChannelNonce This is a unique number used to differentiate channels with an otherwise identical FixedPart . For example, if the same participants want to run the same kind of channel on the same chain as a previous channel, they can choose a new ChannelNonce to prevent state updates for the original channel from being replayed on the new one. Warning You should never join a channel which re-uses a channel nonce. AppDefinition This is an Ethereum address where a Nitro application has been deployed. This is a contract conforming to the ForceMoveApp and defining application rules . Warning You should have confidence that the application is not malicious or suffering from security flaws. You should inspect the source code (which should be publically available and verifiable) or appeal to a trusted authority to do this. ChallengeDuration This is duration (in seconds) of the challenge-response window. If a challenge is raised on chain at time t , the channel will finalize at t + ChallengeDuration unless cleared by a subqsequent on-chain transaction. Warning This should be at least 1 block time (~15 seconds on mainnet) and less than 2^48-1 seconds. Whatever it is set to, the channel should be closed long before 2^48 - 1 - challengeDuration . In practice we recommend somewhere between 5 minutes and 5 months. Variable Part Outcome This describes how funds will be disbursed if the channel were to finalize in the current state. See the section on Outcomes . AppData The AppData is optional data which may be interpreted by the Nitro application and affect the execution rules of the channel -- see the section on application rules . For example, it could describe the state of a chess board or include the hash of a secret. TurnNum The turn number is the mechanism by which newer states take precedence over older ones. The turn number usually increments as the channel progresses. Warning The turn number must not exceed 281,474,976,710,655 because then it will overflow on chain. It should not exceed 4,294,967,295 because it may then overflow off-chain. It is very unlikely a channel would ever have this many updates. IsFinal This is a boolean flag which allows the channel execution rules to be bypassed and for the channel to be finalized \"instantly\" without waiting for the challenge-response window to lapse. Warning As soon as an isFinal=true state is enabled (that is to say, you cannot prevent it from becoming supported) it is not safe to continue executing the state channel. It should be finalized immediately. Channel IDs Channels are identified by the hash of the FixedPart of the state (those parts that may not vary): bytes32 channelId = keccak256 ( abi . encode ( fixedPart . chainId , fixedPart . participants , fixedPart . channelNonce , fixedPart . appDefinition , fixedPart . challengeDuration ) ); State commitments To commit to a state, a hash is formed as follows: bytes32 stateHash = keccak256 ( abi . encode ( channelId , variablePart . appData , variablePart . outcome , variablePart . turnNum , variablePart . isFinal )); and this hash is signed using an dedicated Ethereum private key generated solely for the purpose of executing state channel(s) and not otherwise controlling funds on chain. The signature has the following type: Solidity TypeScript Go struct Signature { uint8 v ; bytes32 r ; bytes32 s ; } import { Signature } from \"ethers\" ; type Signature struct { R [] byte S [] byte V byte } You can sign a state using these utilities: TypeScript Go import { signData } from ' @statechannels / nitro - protocol ; const signature = signData ( stateHash , privateKey ); import nc \"github.com/statechannels/go-nitro/crypto\" signature := nc . SignEthereumMessage ( stateHash . Bytes (), secretKey ) SignedVariableParts Signatures on a state hash by different participants are often bundled up with the variable part of the state when being submitted to chain. Solidity TypeScript Go struct SignedVariablePart { VariablePart variablePart ; Signature [] sigs ; } export interface SignedVariablePart { variablePart : VariablePart ; sigs : Signature []; } // INitroTypesSignedVariablePart is an auto generated low-level Go binding around an user-defined struct. type INitroTypesSignedVariablePart struct { VariablePart INitroTypesVariablePart Sigs [] INitroTypesSignature } Support proofs A support proof is any bundle of information sufficient for the chain to verify that a given channel state is legitimate. They usually consist of FixedPart , plus a singular SignedVariablePart named candidate , plus an array of SignedVariableParts named proof . The trivial support proof is a state with IsFinal: true signed by every participant. For an intuition around more complicated support proofs, see Putting the 'state' in state channels . RecoveredVariableParts The adjudicator smart contract will recover the signer from each signature on a SignedVariablePart , and convert the resulting list into a signedBy bitmask indicating which participant has signed that particular state. The bitfield is bundled with the VariablePart into a RecoveredVariablePart : Solidity TypeScript Go struct RecoveredVariablePart { VariablePart variablePart ; uint256 signedBy ; } export interface RecoveredVariablePart { variablePart : VariablePart ; signedBy : Uint256 ; } // not yet implemented before being passed to the application execution rules (which do not need to do any signature recovery of their own). For example, if a channel has three participants and they all signed the state in question, we would have signedBy = 0b111 = 7 . If only participant with index 0 had signed, we would have signedBy = 0b001 = 1 .","title":"States & Channels"},{"location":"protocol-tutorial/0010-states-channels/#states-channels","text":"A state channel can be thought of as a set of data structures (called \"states\") committed to and exchanged between a fixed set of actors (which we call participants), together with some execution rules. Info In Nitro, participants \"commit to\" a state by digitially signing it. A state channel controls funds which are locked up -- either on an L1 blockchain or on some other ledger such as another state channel. State channel execution may always be disputed on-chain via a contract we call the Adjudicator, although this not necessary.","title":"States &amp; Channels"},{"location":"protocol-tutorial/0010-states-channels/#states","text":"In Nitro protocol, a state is broken up into fixed and variable parts: Solidity TypeScript Go import { ExitFormat as Outcome } from '@statechannels/exit-format/contracts/ExitFormat.sol' ; struct FixedPart { uint256 chainId ; address [] participants ; uint48 channelNonce ; address appDefinition ; uint48 challengeDuration ; } struct VariablePart { Outcome . SingleAssetExit [] outcome ; // (1) bytes appData ; uint48 turnNum ; bool isFinal ; } This composite type is explained in the section on outcomes . import * as ExitFormat from '@statechannels/exit-format' ; // (1) import { Address , Bytes , Bytes32 , Uint256 , Uint48 , Uint64 } from '@statechannels/nitro-protocol' ; export interface FixedPart { chainId : Uint256 ; participants : Address []; channelNonce : Uint64 ; appDefinition : Address ; challengeDuration : Uint48 ; } export interface VariablePart { outcome : ExitFormat.Exit ; // (2) appData : Bytes ; turnNum : Uint48 ; isFinal : boolean ; } Bytes32 , Bytes , Address , Uint256 , Uint64 are aliases to the Javascript string type. They are respresented as hex strings. Uint48 is aliased to a number . This composite type is explained in the section on outcomes . import ( \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" // (1) ) type ( FixedPart struct { ChainId * types . Uint256 Participants [] types . Address ChannelNonce uint64 AppDefinition types . Address ChallengeDuration uint32 } VariablePart struct { AppData types . Bytes Outcome outcome . Exit // (2) TurnNum uint64 IsFinal bool } ) types.Address is an alias to go-ethereum's common.Address type. types.Bytes32 is an alias to go-ethereum's common.Hash type. This composite type is explained in the section on outcomes . Info States are usually submitted to the blockchain as a single fixed part and multiple (signed) variable parts. This is known as a \"support proof\" . Let's take each property in turn:","title":"States"},{"location":"protocol-tutorial/0010-states-channels/#fixed-part","text":"","title":"Fixed Part"},{"location":"protocol-tutorial/0010-states-channels/#chain-id","text":"This needs to match the id of the chain where assets are to be locked (i.e. the 'root' of the funding graph for this channel). In the event of a mismatch, the channel cannot be concluded and funds cannot be unlocked.","title":"Chain id"},{"location":"protocol-tutorial/0010-states-channels/#participants","text":"This is a list of Ethereum addresses, each derived from an ECDSA private key in the usual manner. Each address represents a participant in the state channel who is able to commit to state updates and thereby cause the channel to finalize on chain. Warning Before joining a state channel, you (or your off-chain software) should check that it has length at least 2, but no more than 255, and include a public key (account) that you control. Each entry should be a nonzero ethereum address.","title":"Participants"},{"location":"protocol-tutorial/0010-states-channels/#channelnonce","text":"This is a unique number used to differentiate channels with an otherwise identical FixedPart . For example, if the same participants want to run the same kind of channel on the same chain as a previous channel, they can choose a new ChannelNonce to prevent state updates for the original channel from being replayed on the new one. Warning You should never join a channel which re-uses a channel nonce.","title":"ChannelNonce"},{"location":"protocol-tutorial/0010-states-channels/#appdefinition","text":"This is an Ethereum address where a Nitro application has been deployed. This is a contract conforming to the ForceMoveApp and defining application rules . Warning You should have confidence that the application is not malicious or suffering from security flaws. You should inspect the source code (which should be publically available and verifiable) or appeal to a trusted authority to do this.","title":"AppDefinition"},{"location":"protocol-tutorial/0010-states-channels/#challengeduration","text":"This is duration (in seconds) of the challenge-response window. If a challenge is raised on chain at time t , the channel will finalize at t + ChallengeDuration unless cleared by a subqsequent on-chain transaction. Warning This should be at least 1 block time (~15 seconds on mainnet) and less than 2^48-1 seconds. Whatever it is set to, the channel should be closed long before 2^48 - 1 - challengeDuration . In practice we recommend somewhere between 5 minutes and 5 months.","title":"ChallengeDuration"},{"location":"protocol-tutorial/0010-states-channels/#variable-part","text":"","title":"Variable Part"},{"location":"protocol-tutorial/0010-states-channels/#outcome","text":"This describes how funds will be disbursed if the channel were to finalize in the current state. See the section on Outcomes .","title":"Outcome"},{"location":"protocol-tutorial/0010-states-channels/#appdata","text":"The AppData is optional data which may be interpreted by the Nitro application and affect the execution rules of the channel -- see the section on application rules . For example, it could describe the state of a chess board or include the hash of a secret.","title":"AppData"},{"location":"protocol-tutorial/0010-states-channels/#turnnum","text":"The turn number is the mechanism by which newer states take precedence over older ones. The turn number usually increments as the channel progresses. Warning The turn number must not exceed 281,474,976,710,655 because then it will overflow on chain. It should not exceed 4,294,967,295 because it may then overflow off-chain. It is very unlikely a channel would ever have this many updates.","title":"TurnNum"},{"location":"protocol-tutorial/0010-states-channels/#isfinal","text":"This is a boolean flag which allows the channel execution rules to be bypassed and for the channel to be finalized \"instantly\" without waiting for the challenge-response window to lapse. Warning As soon as an isFinal=true state is enabled (that is to say, you cannot prevent it from becoming supported) it is not safe to continue executing the state channel. It should be finalized immediately.","title":"IsFinal"},{"location":"protocol-tutorial/0010-states-channels/#channel-ids","text":"Channels are identified by the hash of the FixedPart of the state (those parts that may not vary): bytes32 channelId = keccak256 ( abi . encode ( fixedPart . chainId , fixedPart . participants , fixedPart . channelNonce , fixedPart . appDefinition , fixedPart . challengeDuration ) );","title":"Channel IDs"},{"location":"protocol-tutorial/0010-states-channels/#state-commitments","text":"To commit to a state, a hash is formed as follows: bytes32 stateHash = keccak256 ( abi . encode ( channelId , variablePart . appData , variablePart . outcome , variablePart . turnNum , variablePart . isFinal )); and this hash is signed using an dedicated Ethereum private key generated solely for the purpose of executing state channel(s) and not otherwise controlling funds on chain. The signature has the following type: Solidity TypeScript Go struct Signature { uint8 v ; bytes32 r ; bytes32 s ; } import { Signature } from \"ethers\" ; type Signature struct { R [] byte S [] byte V byte } You can sign a state using these utilities: TypeScript Go import { signData } from ' @statechannels / nitro - protocol ; const signature = signData ( stateHash , privateKey ); import nc \"github.com/statechannels/go-nitro/crypto\" signature := nc . SignEthereumMessage ( stateHash . Bytes (), secretKey )","title":"State commitments"},{"location":"protocol-tutorial/0010-states-channels/#signedvariableparts","text":"Signatures on a state hash by different participants are often bundled up with the variable part of the state when being submitted to chain. Solidity TypeScript Go struct SignedVariablePart { VariablePart variablePart ; Signature [] sigs ; } export interface SignedVariablePart { variablePart : VariablePart ; sigs : Signature []; } // INitroTypesSignedVariablePart is an auto generated low-level Go binding around an user-defined struct. type INitroTypesSignedVariablePart struct { VariablePart INitroTypesVariablePart Sigs [] INitroTypesSignature }","title":"SignedVariableParts"},{"location":"protocol-tutorial/0010-states-channels/#support-proofs","text":"A support proof is any bundle of information sufficient for the chain to verify that a given channel state is legitimate. They usually consist of FixedPart , plus a singular SignedVariablePart named candidate , plus an array of SignedVariableParts named proof . The trivial support proof is a state with IsFinal: true signed by every participant. For an intuition around more complicated support proofs, see Putting the 'state' in state channels .","title":"Support proofs"},{"location":"protocol-tutorial/0010-states-channels/#recoveredvariableparts","text":"The adjudicator smart contract will recover the signer from each signature on a SignedVariablePart , and convert the resulting list into a signedBy bitmask indicating which participant has signed that particular state. The bitfield is bundled with the VariablePart into a RecoveredVariablePart : Solidity TypeScript Go struct RecoveredVariablePart { VariablePart variablePart ; uint256 signedBy ; } export interface RecoveredVariablePart { variablePart : VariablePart ; signedBy : Uint256 ; } // not yet implemented before being passed to the application execution rules (which do not need to do any signature recovery of their own). For example, if a channel has three participants and they all signed the state in question, we would have signedBy = 0b111 = 7 . If only participant with index 0 had signed, we would have signedBy = 0b001 = 1 .","title":"RecoveredVariableParts"},{"location":"protocol-tutorial/0020-execution-rules/","text":"Execution Rules The rules dictate the conditions under which a state may be considered supported by the underlying blockchain, and also dictate how one supported state may supercede another. In this manner, state channels may be \"updated\" as participants follow the rules to support state after state. If a state is supported by the underylying blockchain, it has a chance to be the final state for the channel. The final state influences how any assets locked into the channel will be dispersed. Unlike the rules of the underlying blockchain -- which dictate which state history is canoncial via Proof of Work, Proof of Stake, Proof of Authority (or some other hardcoded mechanism) -- Nitro protocol allows for the state channel update rules to vary from one application to another. One state channel might proceed only by unanimous consensus (all parties must digitially sign a state to make it supported), and another might proceed in a round-robin fashion (each party has the chance to support the next state unilaterally). The rules for how one supported state may supercede another are very simple. Each state has a version number, with greater version numbers superceding lesser ones. The state channel rules are enshrined in two places on the blockchain: firstly, in the core protocol , and secondly in the application rules . Participants may provide \"support proofs\" to the blockchain in order to record the execution of the state channel. They will typically prefer to not do that, since it costs gas -- but they will keep such \"support proofs\" in hand in case they need to use them. Core protocol rules Nitro is a very open protocol: This means that very little is stipulated at the core protocol level. Each application gets full control over when a state can be considered supported. The only things enforced by the core protocol are: the rule that higher turn numbers take precedence over lower ones an escape hatch for an \"instant checkout\" of the channel, which bypasses the application rules altogether Otherwise, the core protocol defers to the application rules. Application rules Each channel is required to specify application rules in a contract adhering to the following on chain interface: /** * @dev The IForceMoveApp interface calls for its children to implement an application-specific requireStateSupported function, defining the state machine of a ForceMove state channel DApp. */ interface IForceMoveApp is INitroTypes { /** * @notice Encodes application-specific rules for a particular ForceMove-compliant state channel. Must revert when invalid support proof and a candidate are supplied. * @dev Encodes application-specific rules for a particular ForceMove-compliant state channel. Must revert when invalid support proof and a candidate are supplied. * @param fixedPart Fixed part of the state channel. * @param proof Array of recovered variable parts which constitutes a support proof for the candidate. May be omitted when `candidate` constitutes a support proof itself. * @param candidate Recovered variable part the proof was supplied for. Also may constitute a support proof itself. */ function requireStateSupported ( FixedPart calldata fixedPart , RecoveredVariablePart [] calldata proof , RecoveredVariablePart calldata candidate ) external pure ; } Auxiliary application rules Some of the more advanced features in Nitro are actually expressed themselves as Nitro Applications which we call auxiliary applications . There are a couple of important ones: ConsensusApp The consensus app encodes a very simple rule for execution -- in order for a state to be supported, it must be unanimously countersigned -- that is, signed by all of the channel participants. See the source code . Ledger channels are a special type of channel used to fund other channels -- they are an example of a channel which run the ConsensusApp . VirtualPaymentApp The virtual payment app allows a payer to pay a payee via their inirection connection through n intermediaries. Payments are simply signed \"vouchers\" sent from the payer to the payee . This app is in effect a mini state channel adjudicator, which requires unanimous consensu for most state execution, but parses vouchers and allows for other transitions via forced transtiions (or unilateral consensus). See the source code .","title":"Execution Rules"},{"location":"protocol-tutorial/0020-execution-rules/#execution-rules","text":"The rules dictate the conditions under which a state may be considered supported by the underlying blockchain, and also dictate how one supported state may supercede another. In this manner, state channels may be \"updated\" as participants follow the rules to support state after state. If a state is supported by the underylying blockchain, it has a chance to be the final state for the channel. The final state influences how any assets locked into the channel will be dispersed. Unlike the rules of the underlying blockchain -- which dictate which state history is canoncial via Proof of Work, Proof of Stake, Proof of Authority (or some other hardcoded mechanism) -- Nitro protocol allows for the state channel update rules to vary from one application to another. One state channel might proceed only by unanimous consensus (all parties must digitially sign a state to make it supported), and another might proceed in a round-robin fashion (each party has the chance to support the next state unilaterally). The rules for how one supported state may supercede another are very simple. Each state has a version number, with greater version numbers superceding lesser ones. The state channel rules are enshrined in two places on the blockchain: firstly, in the core protocol , and secondly in the application rules . Participants may provide \"support proofs\" to the blockchain in order to record the execution of the state channel. They will typically prefer to not do that, since it costs gas -- but they will keep such \"support proofs\" in hand in case they need to use them.","title":"Execution Rules"},{"location":"protocol-tutorial/0020-execution-rules/#core-protocol-rules","text":"Nitro is a very open protocol: This means that very little is stipulated at the core protocol level. Each application gets full control over when a state can be considered supported. The only things enforced by the core protocol are: the rule that higher turn numbers take precedence over lower ones an escape hatch for an \"instant checkout\" of the channel, which bypasses the application rules altogether Otherwise, the core protocol defers to the application rules.","title":"Core protocol rules"},{"location":"protocol-tutorial/0020-execution-rules/#application-rules","text":"Each channel is required to specify application rules in a contract adhering to the following on chain interface: /** * @dev The IForceMoveApp interface calls for its children to implement an application-specific requireStateSupported function, defining the state machine of a ForceMove state channel DApp. */ interface IForceMoveApp is INitroTypes { /** * @notice Encodes application-specific rules for a particular ForceMove-compliant state channel. Must revert when invalid support proof and a candidate are supplied. * @dev Encodes application-specific rules for a particular ForceMove-compliant state channel. Must revert when invalid support proof and a candidate are supplied. * @param fixedPart Fixed part of the state channel. * @param proof Array of recovered variable parts which constitutes a support proof for the candidate. May be omitted when `candidate` constitutes a support proof itself. * @param candidate Recovered variable part the proof was supplied for. Also may constitute a support proof itself. */ function requireStateSupported ( FixedPart calldata fixedPart , RecoveredVariablePart [] calldata proof , RecoveredVariablePart calldata candidate ) external pure ; }","title":"Application rules"},{"location":"protocol-tutorial/0020-execution-rules/#auxiliary-application-rules","text":"Some of the more advanced features in Nitro are actually expressed themselves as Nitro Applications which we call auxiliary applications . There are a couple of important ones:","title":"Auxiliary application rules"},{"location":"protocol-tutorial/0020-execution-rules/#consensusapp","text":"The consensus app encodes a very simple rule for execution -- in order for a state to be supported, it must be unanimously countersigned -- that is, signed by all of the channel participants. See the source code . Ledger channels are a special type of channel used to fund other channels -- they are an example of a channel which run the ConsensusApp .","title":"ConsensusApp"},{"location":"protocol-tutorial/0020-execution-rules/#virtualpaymentapp","text":"The virtual payment app allows a payer to pay a payee via their inirection connection through n intermediaries. Payments are simply signed \"vouchers\" sent from the payer to the payee . This app is in effect a mini state channel adjudicator, which requires unanimous consensu for most state execution, but parses vouchers and allows for other transitions via forced transtiions (or unilateral consensus). See the source code .","title":"VirtualPaymentApp"},{"location":"protocol-tutorial/0030-outcomes/","text":"Outcomes The outcome of a state is the part which dictates where funds are disbursed to once the channel has finalized. Nitro protocol uses the L2 exit format , which is designed as standard for supporting a multitude of token types. Tip At the current time, Nitro supports native (e.g. ETH) and ERC20 tokens. An Outcome is an array of SingleAssetExits , each specifying: an asset optional assetMetadata an ordered list of allocations The optional assetMetadata is used only by more exotic asset types, and is zero-ed out for native and ERC20 assets. Allocations An allocation is a destination and an amount an allocationType identifier optional metadata The allocationType identifier is usually set to 0, meaning \"simple\". Simple Allocations Simple allocations do not have any metadata , and allow for funds to be moved on-chain using the transfer method. See the section on defunding . Guarantees When allocationType is set to guarantee , funds cannot be transferred in the usual way. Instead, they may be moved to another channel on chain using the reclaim method. This is explained further in the section on virtual channels. See the section on defunding . The metadata is an encoding of the following struct: struct Guarantee { bytes32 left ; bytes32 right ; } where left and right correspond to channel participants. Destinations A destination is 32 byte identifier which may either denote a channel ID or a so-called \"external destination\" (a 20 byte Ethereum address left-padded with zeros). A simple example Putting these elements together, a simple outcome such as \"5 ETH to Alice, 5 ETH to Bob\" is expressed like this: Typescript Go import { Exit , SingleAssetExit , NullAssetMetadata , } from \"@statechannels/exit-format\" ; const ethExit : SingleAssetExit = { asset : \"0x0\" , // this implies the native token (e.g. ETH) assetMetadata : NullAssetMetadata , // Intentionally left blank allocations : [ { destination : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" , // Alice amount : \"0x05\" , allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, { destination : \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , // Bob amount : \"0x05\" , allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, ], }; const exit = [ ethExit ]; import ( \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" ) var ethExit = outcome . SingleAssetExit { Allocations : outcome . Allocations { outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" )), // Alice Amount : big . NewInt ( 5 ), // Other fields implicitly zero-ed out }, outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" )), // Bob Amount : big . NewInt ( 5 ), // Other fields implicitly zero-ed out }, }, } var exit = outcome . Exit {{ ethExit }}","title":"Outcomes"},{"location":"protocol-tutorial/0030-outcomes/#outcomes","text":"The outcome of a state is the part which dictates where funds are disbursed to once the channel has finalized. Nitro protocol uses the L2 exit format , which is designed as standard for supporting a multitude of token types. Tip At the current time, Nitro supports native (e.g. ETH) and ERC20 tokens. An Outcome is an array of SingleAssetExits , each specifying: an asset optional assetMetadata an ordered list of allocations The optional assetMetadata is used only by more exotic asset types, and is zero-ed out for native and ERC20 assets.","title":"Outcomes"},{"location":"protocol-tutorial/0030-outcomes/#allocations","text":"An allocation is a destination and an amount an allocationType identifier optional metadata The allocationType identifier is usually set to 0, meaning \"simple\".","title":"Allocations"},{"location":"protocol-tutorial/0030-outcomes/#simple-allocations","text":"Simple allocations do not have any metadata , and allow for funds to be moved on-chain using the transfer method. See the section on defunding .","title":"Simple Allocations"},{"location":"protocol-tutorial/0030-outcomes/#guarantees","text":"When allocationType is set to guarantee , funds cannot be transferred in the usual way. Instead, they may be moved to another channel on chain using the reclaim method. This is explained further in the section on virtual channels. See the section on defunding . The metadata is an encoding of the following struct: struct Guarantee { bytes32 left ; bytes32 right ; } where left and right correspond to channel participants.","title":"Guarantees"},{"location":"protocol-tutorial/0030-outcomes/#destinations","text":"A destination is 32 byte identifier which may either denote a channel ID or a so-called \"external destination\" (a 20 byte Ethereum address left-padded with zeros).","title":"Destinations"},{"location":"protocol-tutorial/0030-outcomes/#a-simple-example","text":"Putting these elements together, a simple outcome such as \"5 ETH to Alice, 5 ETH to Bob\" is expressed like this: Typescript Go import { Exit , SingleAssetExit , NullAssetMetadata , } from \"@statechannels/exit-format\" ; const ethExit : SingleAssetExit = { asset : \"0x0\" , // this implies the native token (e.g. ETH) assetMetadata : NullAssetMetadata , // Intentionally left blank allocations : [ { destination : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" , // Alice amount : \"0x05\" , allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, { destination : \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , // Bob amount : \"0x05\" , allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, ], }; const exit = [ ethExit ]; import ( \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" ) var ethExit = outcome . SingleAssetExit { Allocations : outcome . Allocations { outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" )), // Alice Amount : big . NewInt ( 5 ), // Other fields implicitly zero-ed out }, outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" )), // Bob Amount : big . NewInt ( 5 ), // Other fields implicitly zero-ed out }, }, } var exit = outcome . Exit {{ ethExit }}","title":"A simple example"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/","text":"Lifecycle of a state channel In this section we'll consider the \"state\" of a state channel as composite of three states -- the off chain state , the on chain adjudication state and the funding state (which can be on or off chain). The off chain parts of the state may be different for each participant in the channel, whereas the on chain part of the state is considered consistent (up to issues to do with finality and chain reorgs). Info \"State\" is a highly overloaded term -- in this section we take it to mean something different from the \"state\" of the section on states (unless explicitly noted). Off-chain lifecycle The off-chain lifecycle of a channel may be visualized like this: stateDiagram-v2 state OffChain { [*] --> Proposed Proposed --> ReadyToFund ReadyToFund --> Funded Funded --> Running Running --> Finalized } The conditions for each state emerge from the collection of states and signatures held by each participant. Let's look at each in turn. Proposed This state applies as soon as a participant commits to a state with turnNum=0 known as the prefund state. This is typically broadcast to other participants who may countersign it to indicate their agreement to join the channel. ReadyToFund This state applies when all participants commit to the prefund state, i.e. when all prefund signatures are in hand. Info It is important to wait for a supported prefund before depositing any funds on chain, since this state is a guarantee that on chain funds can be unlocked with the intial (prefund) outcome . Funded This state applies when all participants commit to a state with turnNum=1 known as the postfund state. Each participant should only make this commitment when one of the following is true: sufficient deposits are accrued on chain against the channel in question sufficient money is directly allocated to the channel in question from an existing funded channel sufficient money is guaranteed to the channel in question from an existing funded channel For more detail see the section on funding . Running This state applies when a state with turnNum > 1 becomes supported. Finalized This state applies when all participants commit to a state with isFinal=true , i.e. when all final signatures are in hand. Info Each state supercedes the previous ones in the sense that (for example) a channel is said to be Funded if it meets that condition, even though it also meets the condition for ReadyToFund . Funding lifecycle A channel may be funded either on-chain or off-chain. The state can be visualized like this: stateDiagram-v2 state OnChain { state Funding { [*]-->NotFundedOnChain NotFundedOnChain --> FundedOnChain FundedOnChain --> NotFundedOnChain } } state OffChain { state Fundings { [*]-->NotFundedOffChain NotFundedOffChain --> FundedOffChain FundedOffChain --> NotFundedOffChain } } The channel should be funded when the off chain state is ReadyToFund , and defunded when the off chain state is Finalized . On-chain When a channel is to be funded on chain, participants follow the on chain deposit protocol . When sufficient funds are deposited against the channel, the state has transitioned to FundedOnChain . Off-chain Funding on chain is often not necessary, since most channels are funded off-chain. In that case, the \"funding state\" of a channel is composed of the off-chain state of one or more other channels. See the section on funding . Adjudication lifecyle The adjudicator smart contract (henceforth \"adjudicator\") is the main on-chain code governing the state channel network. It stores certain information about any channel that it knows about. The off chain state may be submitted to the adjudicator at any time to trigger the adjudication status of a channel to change. The adjudication status of a channel is composed of several variables, but these are summarized in finite states Open , Challenge and Finalized -- these are called channel modes . Channel Modes A channel is in one or the other of three modes, which can be represented in the following state machine: stateDiagram-v2 state OnChain { state Adjudication { Open -->Challenge: challenge Open --> Open: checkpoint Open--> Finalized: conclude Challenge--> Challenge: challenge Challenge--> Open: respond Challenge--> Open: checkpoint Challenge--> Finalized: conclude Challenge--> Finalized': timeout } } Here Finalized and Finalized' are distinct states reflecting the fact that the on-chain storage is slightly different in each case, although the implications are the same (the channel may now be defunded on chain). Most of the transitions between states can be understood via the section on finalizing a channel . The remaining transition timeout is a passive transition which happens when a block is produced with a sufficiently large timestamp. Tip Ideally channels are never adjudicated on chain. This only state applies as a last resort when cooperation has broken down. The channel mode is derived from other status data stored on chain using this function: /** * @notice Computes the ChannelMode for a given channelId. * @dev Computes the ChannelMode for a given channelId. * @param channelId Unique identifier for a channel. */ function _mode ( bytes32 channelId ) internal view returns ( ChannelMode ) { // Note that _unpackStatus(someRandomChannelId) returns (0,0,0), which is // correct when nobody has written to storage yet. (, uint48 finalizesAt , ) = _unpackStatus ( channelId ); if ( finalizesAt == 0 ) { return ChannelMode . Open ; // solhint-disable-next-line not-rely-on-time } else if ( finalizesAt <= block.timestamp ) { return ChannelMode . Finalized ; } else { return ChannelMode . Challenge ; } } finalizesAt As you can see, the channel mode is determined by the relation between the timestamp of the current block and the finalizesAt timestamp stored on chain. When finalizesAt is in the past, the channel is Finalized ; when it is in the future, the channel is in Challenge . When it is (the magic and initial value of ) 0 , the channel is Open . turnNumRecord turNumRecord is the highest turn number that is known to the chain to be supported by a full set of signatures. The exception to this rule is that it is set to 0 when the channel is concluded via a conclude call. For example, the turnNumRecord might be increased by a submitted checkpoint transaction including a support proof for a state. fingerprint The fingerprint helps to uniquely identify the channel's current state, up to hash collisions. It is computed as: uint160 ( uint256 ( keccak256 ( abi . encode ( stateHash , // (1) outcomeHash // (2) ) ) ) ) This is formed according to this formula . This is formed by a simple abi-encode and keccack256 recipe. Adjudicator storage Status data is stored inside the adjudicator in the following mapping (with channelId as the key): mapping ( bytes32 => bytes32 ) public statusOf ; Generating a 32 byte status involves setting the most significant 48 bits to the turnNumRecord setting the next most significant 48 bits to finalizesAt setting the next most significant 160 bits to the fingerprint When the adjudicator needs to verify the exact state or outcome, the data is provided in the function arguments, as part of the calldata . The chain will then check that the hydrated data matches the status that has been stored. Info turnNumRecord and finalizesAt can be read from storage straightforwardly, whereas the other ChannelData fields are only stored as the output of a one-way function. The input to this function must therefore be tracked in client code by monitoring the relevant contract events. We provide a helper function to construct the appropriate status from a javascript representation of ChannelData : import { ChannelData , channelDataToFingerprint , } from \"@statechannels/nitro-protocol\" ; const channelData : ChannelData = { turnNumRecord : largestTurnNum , finalizesAt : 0x0 , }; const status = channelDataToStatus ( channelData ); Here we omitted some of the fields, because the helper function is smart enough to know to set them to null values when finalizes at is zero.","title":"Lifecycle of a state channel"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#lifecycle-of-a-state-channel","text":"In this section we'll consider the \"state\" of a state channel as composite of three states -- the off chain state , the on chain adjudication state and the funding state (which can be on or off chain). The off chain parts of the state may be different for each participant in the channel, whereas the on chain part of the state is considered consistent (up to issues to do with finality and chain reorgs). Info \"State\" is a highly overloaded term -- in this section we take it to mean something different from the \"state\" of the section on states (unless explicitly noted).","title":"Lifecycle of a state channel"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#off-chain-lifecycle","text":"The off-chain lifecycle of a channel may be visualized like this: stateDiagram-v2 state OffChain { [*] --> Proposed Proposed --> ReadyToFund ReadyToFund --> Funded Funded --> Running Running --> Finalized } The conditions for each state emerge from the collection of states and signatures held by each participant. Let's look at each in turn.","title":"Off-chain lifecycle"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#proposed","text":"This state applies as soon as a participant commits to a state with turnNum=0 known as the prefund state. This is typically broadcast to other participants who may countersign it to indicate their agreement to join the channel.","title":"Proposed"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#readytofund","text":"This state applies when all participants commit to the prefund state, i.e. when all prefund signatures are in hand. Info It is important to wait for a supported prefund before depositing any funds on chain, since this state is a guarantee that on chain funds can be unlocked with the intial (prefund) outcome .","title":"ReadyToFund"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#funded","text":"This state applies when all participants commit to a state with turnNum=1 known as the postfund state. Each participant should only make this commitment when one of the following is true: sufficient deposits are accrued on chain against the channel in question sufficient money is directly allocated to the channel in question from an existing funded channel sufficient money is guaranteed to the channel in question from an existing funded channel For more detail see the section on funding .","title":"Funded"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#running","text":"This state applies when a state with turnNum > 1 becomes supported.","title":"Running"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#finalized","text":"This state applies when all participants commit to a state with isFinal=true , i.e. when all final signatures are in hand. Info Each state supercedes the previous ones in the sense that (for example) a channel is said to be Funded if it meets that condition, even though it also meets the condition for ReadyToFund .","title":"Finalized"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#funding-lifecycle","text":"A channel may be funded either on-chain or off-chain. The state can be visualized like this: stateDiagram-v2 state OnChain { state Funding { [*]-->NotFundedOnChain NotFundedOnChain --> FundedOnChain FundedOnChain --> NotFundedOnChain } } state OffChain { state Fundings { [*]-->NotFundedOffChain NotFundedOffChain --> FundedOffChain FundedOffChain --> NotFundedOffChain } } The channel should be funded when the off chain state is ReadyToFund , and defunded when the off chain state is Finalized .","title":"Funding lifecycle"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#on-chain","text":"When a channel is to be funded on chain, participants follow the on chain deposit protocol . When sufficient funds are deposited against the channel, the state has transitioned to FundedOnChain .","title":"On-chain"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#off-chain","text":"Funding on chain is often not necessary, since most channels are funded off-chain. In that case, the \"funding state\" of a channel is composed of the off-chain state of one or more other channels. See the section on funding .","title":"Off-chain"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#adjudication-lifecyle","text":"The adjudicator smart contract (henceforth \"adjudicator\") is the main on-chain code governing the state channel network. It stores certain information about any channel that it knows about. The off chain state may be submitted to the adjudicator at any time to trigger the adjudication status of a channel to change. The adjudication status of a channel is composed of several variables, but these are summarized in finite states Open , Challenge and Finalized -- these are called channel modes .","title":"Adjudication lifecyle"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#channel-modes","text":"A channel is in one or the other of three modes, which can be represented in the following state machine: stateDiagram-v2 state OnChain { state Adjudication { Open -->Challenge: challenge Open --> Open: checkpoint Open--> Finalized: conclude Challenge--> Challenge: challenge Challenge--> Open: respond Challenge--> Open: checkpoint Challenge--> Finalized: conclude Challenge--> Finalized': timeout } } Here Finalized and Finalized' are distinct states reflecting the fact that the on-chain storage is slightly different in each case, although the implications are the same (the channel may now be defunded on chain). Most of the transitions between states can be understood via the section on finalizing a channel . The remaining transition timeout is a passive transition which happens when a block is produced with a sufficiently large timestamp. Tip Ideally channels are never adjudicated on chain. This only state applies as a last resort when cooperation has broken down. The channel mode is derived from other status data stored on chain using this function: /** * @notice Computes the ChannelMode for a given channelId. * @dev Computes the ChannelMode for a given channelId. * @param channelId Unique identifier for a channel. */ function _mode ( bytes32 channelId ) internal view returns ( ChannelMode ) { // Note that _unpackStatus(someRandomChannelId) returns (0,0,0), which is // correct when nobody has written to storage yet. (, uint48 finalizesAt , ) = _unpackStatus ( channelId ); if ( finalizesAt == 0 ) { return ChannelMode . Open ; // solhint-disable-next-line not-rely-on-time } else if ( finalizesAt <= block.timestamp ) { return ChannelMode . Finalized ; } else { return ChannelMode . Challenge ; } }","title":"Channel Modes"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#finalizesat","text":"As you can see, the channel mode is determined by the relation between the timestamp of the current block and the finalizesAt timestamp stored on chain. When finalizesAt is in the past, the channel is Finalized ; when it is in the future, the channel is in Challenge . When it is (the magic and initial value of ) 0 , the channel is Open .","title":"finalizesAt"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#turnnumrecord","text":"turNumRecord is the highest turn number that is known to the chain to be supported by a full set of signatures. The exception to this rule is that it is set to 0 when the channel is concluded via a conclude call. For example, the turnNumRecord might be increased by a submitted checkpoint transaction including a support proof for a state.","title":"turnNumRecord"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#fingerprint","text":"The fingerprint helps to uniquely identify the channel's current state, up to hash collisions. It is computed as: uint160 ( uint256 ( keccak256 ( abi . encode ( stateHash , // (1) outcomeHash // (2) ) ) ) ) This is formed according to this formula . This is formed by a simple abi-encode and keccack256 recipe.","title":"fingerprint"},{"location":"protocol-tutorial/0040-lifecycle-of-a-channel/#adjudicator-storage","text":"Status data is stored inside the adjudicator in the following mapping (with channelId as the key): mapping ( bytes32 => bytes32 ) public statusOf ; Generating a 32 byte status involves setting the most significant 48 bits to the turnNumRecord setting the next most significant 48 bits to finalizesAt setting the next most significant 160 bits to the fingerprint When the adjudicator needs to verify the exact state or outcome, the data is provided in the function arguments, as part of the calldata . The chain will then check that the hydrated data matches the status that has been stored. Info turnNumRecord and finalizesAt can be read from storage straightforwardly, whereas the other ChannelData fields are only stored as the output of a one-way function. The input to this function must therefore be tracked in client code by monitoring the relevant contract events. We provide a helper function to construct the appropriate status from a javascript representation of ChannelData : import { ChannelData , channelDataToFingerprint , } from \"@statechannels/nitro-protocol\" ; const channelData : ChannelData = { turnNumRecord : largestTurnNum , finalizesAt : 0x0 , }; const status = channelDataToStatus ( channelData ); Here we omitted some of the fields, because the helper function is smart enough to know to set them to null values when finalizes at is zero.","title":"Adjudicator storage"},{"location":"protocol-tutorial/0050-precautions-and-limits/","text":"Precautions and Limits Precautions As a state channel participant, it is advised to check the FixedPart of any channel before joining it. The section on states explains these checks. Limits There are also some limits to be aware of, which apply to the VariablePart . We describe these limits via some exported constants: import { MAX_TX_DATA_SIZE , MAX_OUTCOME_ITEMS , NITRO_MAX_GAS , } from \"@statechannels/nitro-protocol\" ; Constant Notes MAX_TX_DATA_SIZE Reflects the typical effective maximum size for ethereum transaction data. This is set by ethereum clients such as geth . At the time of writing this is 128KB. NITRO_MAX_GAS An upper limit on the gas consumed by a transaction that we consider \"safe\" in the sense that it is below the block gas limit on mainnet and most testnets. At the time of writing this constant is set to 6M gas. MAX_OUTCOME_ITEMS Denotes a safe upper limit on the number of allocationItems that may be stored in an outcome . We deem this number safe because the resulting transaction size is less than MAX_TX_DATA_SIZE and the transaction consumes less than NITRO_MAX_GAS (as confirmed by our test suite). This is for the challenge transaction, with the other fields in the state set to modest values (e.g. 2 participants). If those fields grow, MAX_OUTCOME_ITEMS may no longer be safe. At the time of writing this constant is set to 2000 allocation items. Paying out tokens from a state channel is potentially one of the most expensive operations from a gas perspective (if the recipient does not have any already, the transaction will consume 20K gas per pay out). The same is true of channels paying out (ETH or tokens) to other channels on chain. Bear this in mind when deciding whether to transfer one, many-at-a-time or all-at-once of the tokens from a finalized channel outcome. NITRO_MAX_GAS / 20000 would be a sensible choice. Remember to leave some headroom for the transfer method's intrinsic gas costs: our test suite confirms that at least 100 Token payouts are possible. TLDR: stick to outcomes withe fewer than MAX_OUTCOME_ITEMS entries, and don't try to transfer many more than NITRO_MAX_GAS / 20000 tokens in one transfer transaction.","title":"Precautions and Limits"},{"location":"protocol-tutorial/0050-precautions-and-limits/#precautions-and-limits","text":"","title":"Precautions and Limits"},{"location":"protocol-tutorial/0050-precautions-and-limits/#precautions","text":"As a state channel participant, it is advised to check the FixedPart of any channel before joining it. The section on states explains these checks.","title":"Precautions"},{"location":"protocol-tutorial/0050-precautions-and-limits/#limits","text":"There are also some limits to be aware of, which apply to the VariablePart . We describe these limits via some exported constants: import { MAX_TX_DATA_SIZE , MAX_OUTCOME_ITEMS , NITRO_MAX_GAS , } from \"@statechannels/nitro-protocol\" ; Constant Notes MAX_TX_DATA_SIZE Reflects the typical effective maximum size for ethereum transaction data. This is set by ethereum clients such as geth . At the time of writing this is 128KB. NITRO_MAX_GAS An upper limit on the gas consumed by a transaction that we consider \"safe\" in the sense that it is below the block gas limit on mainnet and most testnets. At the time of writing this constant is set to 6M gas. MAX_OUTCOME_ITEMS Denotes a safe upper limit on the number of allocationItems that may be stored in an outcome . We deem this number safe because the resulting transaction size is less than MAX_TX_DATA_SIZE and the transaction consumes less than NITRO_MAX_GAS (as confirmed by our test suite). This is for the challenge transaction, with the other fields in the state set to modest values (e.g. 2 participants). If those fields grow, MAX_OUTCOME_ITEMS may no longer be safe. At the time of writing this constant is set to 2000 allocation items. Paying out tokens from a state channel is potentially one of the most expensive operations from a gas perspective (if the recipient does not have any already, the transaction will consume 20K gas per pay out). The same is true of channels paying out (ETH or tokens) to other channels on chain. Bear this in mind when deciding whether to transfer one, many-at-a-time or all-at-once of the tokens from a finalized channel outcome. NITRO_MAX_GAS / 20000 would be a sensible choice. Remember to leave some headroom for the transfer method's intrinsic gas costs: our test suite confirms that at least 100 Token payouts are possible. TLDR: stick to outcomes withe fewer than MAX_OUTCOME_ITEMS entries, and don't try to transfer many more than NITRO_MAX_GAS / 20000 tokens in one transfer transaction.","title":"Limits"},{"location":"protocol-tutorial/0060-funding-a-channel/","text":"Funding a channel Early on in the lifecycle of a state channel -- i.e. after exchanging some setup states, but before executing any application logic -- participants will want to \"fund it\". They will stake assets on the channel so that the state updates are meaningful. The simplest way to do this is with an on chain deposit; a more advanced possibility is fund a new channel from an existing funded channel. Fund with an on-chain deposit The deposit method allows ETH or ERC20 tokens to be escrowed against a channel. We have the following call signature: function deposit ( address asset , bytes32 destination , uint256 expectedHeld , uint256 amount ) public payable Warning There are a few rules to obey when calling deposit . Firstly, destination must NOT be an external destination . Secondly, the on-chain holdings for destination must be greater than or equal to expectedHeld . Thirdly, the holdings for destination must be less than the sum of the amount expected to be held and the amount declared in the deposit. The first rule prevents funds being escrowed against something other than a channelId: funds may only be unlocked from channels, so you shouldn't deposit into anything else. The second rule prevents loss of funds: since holdings are paid out in preferential order, depositing before a counterparty has deposited implies that they can withdraw your funds. The check is performed in the same transaction as the deposit, making this safe even in the event of a chain re-org that reverts a previous participant's deposit. The third rule prevents the deposit of uneccessary funds: if my aim was to increase the holdings to a certain level, but they are already at or above that level, then I want my deposit to transaction revert. If we are depositing ETH, we must remember to send the right amount of ETH with the transaction, and to set the asset parameter to the zero address. import { ethers , constants } from \"ethers\" ; import { randomChannelId } from \"@statechannels/nitro-protocol\" ; /* Get an appropriate representation of 1 wei, and use randomChannelId() as a dummy channelId. WARNING: don't do this in the wild: you won't be able to recover these funds. */ const amount = ethers . utils . parseUnits ( \"1\" , \"wei\" ); const destination = randomChannelId (); /* Attempt to deposit 1 wei against the channel id we created. Inspect the error message in the console for a hint about the bug on the next line */ const expectedHeld = 0 ; const tx0 = NitroAdjudicator . deposit ( constants . AddressZero , // (1) destination , expectedHeld , amount , { value : amount , } ); This magic value declares that this is a native token deposit (e.g. ETH). Otherwise, if we are depositing ERC20 tokens, we must remember to approve the NitroAdjudicator for enough tokens before making the deposit, and then call deposit with the ERC20 token contract address as the first parameter (instead of the zero address). Outcome priority In Nitro, it is possible for a channel to be underfunded, exactly funded or overfunded at different points in time. Particularly during depositing, there are fewer funds held against the channel than are allocated by it (i.e. it is underfunded). If a channel were to finalize and be liquidated when underfunded (something which could happen), the funds would be paid out in priority order. This implies that depositing safely requires an understanding of that priority order -- in essence, participants should not deposit until those with higher priority have had their deposits confirmed. Fund from an existing channel In most cases, there should be no need to pay the cost and latency of funding on chain. All it takes to fund a second channel (say, X ) off-chain from a first (sa,y L ) is to make a state update in L . The participants of L can collaborate to support a state with a modififed outcome . This is particularly straightforward if the first channel is running the ConsensusApp . Info In this context, the channel L is known as a ledger channel . Take for example an initial funding tree like this: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|5|me; ledger-->|5|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 The diagram shows on-chain funding of 10 for L , which initially allocates 5 to each participant. The participants propose and countersign a modified outcome like so: Typescript Go import { Exit , SingleAssetExit , NullAssetMetadata , } from \"@statechannels/exit-format\" ; const ethExit : SingleAssetExit = { asset : \"0x0\" , assetMetadata : NullAssetMetadata , allocations : [ { destination : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" , // Alice amount : \"0x02\" , // (1) allocationType : AllocationType.simple , metadata : \"0x\" , }, { destination : \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , // Bob amount : \"0x02\" , // (2) allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, { // (3) // The channel id of the second channel: destination : \"0xC4f161b9490737369d5F8525D039038Da1EdBAC4\" , amount : \"0x06\" , allocationType : AllocationType.simple , metadata : \"0x\" , }, ], }; const exit = [ ethExit ]; This amount was decremented by 3. This amount was decremented by 3. This allocation was appended. import ( \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" ) var ethExit = outcome . SingleAssetExit { Allocations : outcome . Allocations { outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" )), Amount : big . NewInt ( 2 ), // (1) }, outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" )), Amount : big . NewInt ( 2 ), // (2) }, outcome . Allocation { // (3) // The channel id of the second channel: Destination : types . Destination ( common . HexToHash ( \"0xC4f161b9490737369d5F8525D039038Da1EdBAC4\" )), Amount : big . NewInt ( 6 ), }, }, } var exit = outcome . Exit {{ ethExit }} This amount was decremented by 3. This amount was decremented by 3. This allocation was appended. Bringing the funding graph to a state like this: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ledger-->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 Fund virtually It is possible to virtually fund a channel with a counterparty via two or more channels which constitute an indirect pre-existing connection with that counterparty. Take for example an initial funding tree like this: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledgerL((L)) ledgerM((M)) ledgerR((R)) me((A)):::me hub1((I1)):::hub1 hub2((I2)):::hub2 counterparty((B)):::bob ETHAssetHolder-->|10|ledgerL; ETHAssetHolder-->|10|ledgerM; ETHAssetHolder-->|10|ledgerR; ledgerL-->|5|me; ledgerL-->|5|hub1; ledgerM-->|5|hub1; ledgerM-->|5|hub2; ledgerR-->|5|hub2; ledgerR-->|5|counterparty; classDef me fill:#4287f5 classDef hub1 fill:#85e69f classDef hub2 fill:#f242f5 classDef bob fill:#d93434 Here A wishes to enter a channel with B , but only has a ledger channel with I1 . However, since I1 has a ledger channel with I2 , and I2 has a ledger channel with B , it is indeed possible to safely fund such a channel in the following way. A proposes a channel V with participants A,I1,I2,B . Each participant has a numerical role in the virtual funding protocol. V allocates funds to A and B , but not to ther intermediaries I1,I2 . The other participants join the channel. See lifecycle of a channel . In each existing ledger channel ( L,M,R ), the participants of that channel make an update to include a guarantee for V in the outcome of the ledger channel. When all of the ledger channels (there will be 1 or 2) which an actor is participating in have reached consensus on guaranteeing V , that actor signs the postfund state for V . When the postfund round completes, the channel is considered funded. Here is an example of step 2 for M , the ledger channel between A and I1 : Typescript Go import { Exit , SingleAssetExit , NullAssetMetadata , } from \"@statechannels/exit-format\" ; const ethExit : SingleAssetExit = { asset : \"0x0\" , assetMetadata : NullAssetMetadata , allocations : [ { destination : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" , // Alice amount : \"0x04\" , // (1) allocationType : AllocationType.simple , metadata : \"0x\" , }, { destination : \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , // Bob amount : \"0x04\" , // (2) allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, { // (3) // The channel id of V: destination : \"0x0737369d5F8C4f161b949525D039038Da1EdBAC4\" , amount : \"0x02\" , allocationType : AllocationType.Guarantee , metadata : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , }, ], }; const exit = [ ethExit ]; This amount was decremented by 1. This amount was decremented by 1. This allocation was appended. Notice that it is a guarantee allocation. import ( \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" ) var aliceDestination := types . Destination ( common . HexToHash ( \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" )) var I1Destination := types . Destination ( common . HexToHash ( \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" )) var ethExit = outcome . SingleAssetExit { Allocations : outcome . Allocations { outcome . Allocation { Destination : aliceDestination , Amount : big . NewInt ( 4 ), // (1) }, outcome . Allocation { Destination : I1Destination , Amount : big . NewInt ( 4 ), // (2) }, outcome . Allocation { // (3) // The channel id of V: Destination : types . Destination ( common . HexToHash ( \"0x0737369d5F8C4f161b949525D039038Da1EdBAC4\" )), Amount : big . NewInt ( 2 ), Metadata : append ( aliceDestination . Bytes (), I1Destination . Bytes () ... ) }, }, } var exit = outcome . Exit {{ ethExit }} This amount was decremented by 1. This amount was decremented by 1. This allocation was appended. Notice that it is a guarantee allocation. Note how the additional allocation is a guarantee allocation. and has appropriately encoded metadata. If the ledger channels are labelled L_i and ordered left to right by participant role, the left metadata field in L_i 's guarantee is set to participant P_i 's destination and the right metadata field is set to participant P_(i+1) 's destiantion. And once steps 1-4 are complete, the funding graph looks like so: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledgerL((L)) ledgerM((M)) ledgerR((R)) V((V)) me((A)):::me hub1((I1)):::hub1 hub2((I2)):::hub2 counterparty((B)):::bob ETHAssetHolder-->|10|ledgerL; ETHAssetHolder-->|10|ledgerM; ETHAssetHolder-->|10|ledgerR; ledgerL-->|4|me; ledgerL-->|4|hub1; ledgerM-->|4|hub1; ledgerM-->|4|hub2; ledgerR-->|4|hub2; ledgerR-->|4|counterparty; ledgerL-..->|2|V; ledgerM-..->|2|V; ledgerR-..->|2|V; classDef me fill:#4287f5 classDef hub1 fill:#85e69f classDef hub2 fill:#f242f5 classDef bob fill:#d93434 This construction generalizes, and works with anything from 1 , 2 (as shown here) or n hops. Channel V may be used for A to send payments to B , for example: see virtual payment app .","title":"Funding a channel"},{"location":"protocol-tutorial/0060-funding-a-channel/#funding-a-channel","text":"Early on in the lifecycle of a state channel -- i.e. after exchanging some setup states, but before executing any application logic -- participants will want to \"fund it\". They will stake assets on the channel so that the state updates are meaningful. The simplest way to do this is with an on chain deposit; a more advanced possibility is fund a new channel from an existing funded channel.","title":"Funding a channel"},{"location":"protocol-tutorial/0060-funding-a-channel/#fund-with-an-on-chain-deposit","text":"The deposit method allows ETH or ERC20 tokens to be escrowed against a channel. We have the following call signature: function deposit ( address asset , bytes32 destination , uint256 expectedHeld , uint256 amount ) public payable Warning There are a few rules to obey when calling deposit . Firstly, destination must NOT be an external destination . Secondly, the on-chain holdings for destination must be greater than or equal to expectedHeld . Thirdly, the holdings for destination must be less than the sum of the amount expected to be held and the amount declared in the deposit. The first rule prevents funds being escrowed against something other than a channelId: funds may only be unlocked from channels, so you shouldn't deposit into anything else. The second rule prevents loss of funds: since holdings are paid out in preferential order, depositing before a counterparty has deposited implies that they can withdraw your funds. The check is performed in the same transaction as the deposit, making this safe even in the event of a chain re-org that reverts a previous participant's deposit. The third rule prevents the deposit of uneccessary funds: if my aim was to increase the holdings to a certain level, but they are already at or above that level, then I want my deposit to transaction revert. If we are depositing ETH, we must remember to send the right amount of ETH with the transaction, and to set the asset parameter to the zero address. import { ethers , constants } from \"ethers\" ; import { randomChannelId } from \"@statechannels/nitro-protocol\" ; /* Get an appropriate representation of 1 wei, and use randomChannelId() as a dummy channelId. WARNING: don't do this in the wild: you won't be able to recover these funds. */ const amount = ethers . utils . parseUnits ( \"1\" , \"wei\" ); const destination = randomChannelId (); /* Attempt to deposit 1 wei against the channel id we created. Inspect the error message in the console for a hint about the bug on the next line */ const expectedHeld = 0 ; const tx0 = NitroAdjudicator . deposit ( constants . AddressZero , // (1) destination , expectedHeld , amount , { value : amount , } ); This magic value declares that this is a native token deposit (e.g. ETH). Otherwise, if we are depositing ERC20 tokens, we must remember to approve the NitroAdjudicator for enough tokens before making the deposit, and then call deposit with the ERC20 token contract address as the first parameter (instead of the zero address).","title":"Fund with an on-chain deposit"},{"location":"protocol-tutorial/0060-funding-a-channel/#outcome-priority","text":"In Nitro, it is possible for a channel to be underfunded, exactly funded or overfunded at different points in time. Particularly during depositing, there are fewer funds held against the channel than are allocated by it (i.e. it is underfunded). If a channel were to finalize and be liquidated when underfunded (something which could happen), the funds would be paid out in priority order. This implies that depositing safely requires an understanding of that priority order -- in essence, participants should not deposit until those with higher priority have had their deposits confirmed.","title":"Outcome priority"},{"location":"protocol-tutorial/0060-funding-a-channel/#fund-from-an-existing-channel","text":"In most cases, there should be no need to pay the cost and latency of funding on chain. All it takes to fund a second channel (say, X ) off-chain from a first (sa,y L ) is to make a state update in L . The participants of L can collaborate to support a state with a modififed outcome . This is particularly straightforward if the first channel is running the ConsensusApp . Info In this context, the channel L is known as a ledger channel . Take for example an initial funding tree like this: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|5|me; ledger-->|5|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 The diagram shows on-chain funding of 10 for L , which initially allocates 5 to each participant. The participants propose and countersign a modified outcome like so: Typescript Go import { Exit , SingleAssetExit , NullAssetMetadata , } from \"@statechannels/exit-format\" ; const ethExit : SingleAssetExit = { asset : \"0x0\" , assetMetadata : NullAssetMetadata , allocations : [ { destination : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" , // Alice amount : \"0x02\" , // (1) allocationType : AllocationType.simple , metadata : \"0x\" , }, { destination : \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , // Bob amount : \"0x02\" , // (2) allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, { // (3) // The channel id of the second channel: destination : \"0xC4f161b9490737369d5F8525D039038Da1EdBAC4\" , amount : \"0x06\" , allocationType : AllocationType.simple , metadata : \"0x\" , }, ], }; const exit = [ ethExit ]; This amount was decremented by 3. This amount was decremented by 3. This allocation was appended. import ( \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" ) var ethExit = outcome . SingleAssetExit { Allocations : outcome . Allocations { outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" )), Amount : big . NewInt ( 2 ), // (1) }, outcome . Allocation { Destination : types . Destination ( common . HexToHash ( \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" )), Amount : big . NewInt ( 2 ), // (2) }, outcome . Allocation { // (3) // The channel id of the second channel: Destination : types . Destination ( common . HexToHash ( \"0xC4f161b9490737369d5F8525D039038Da1EdBAC4\" )), Amount : big . NewInt ( 6 ), }, }, } var exit = outcome . Exit {{ ethExit }} This amount was decremented by 3. This amount was decremented by 3. This allocation was appended. Bringing the funding graph to a state like this: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ledger-->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434","title":"Fund from an existing channel"},{"location":"protocol-tutorial/0060-funding-a-channel/#fund-virtually","text":"It is possible to virtually fund a channel with a counterparty via two or more channels which constitute an indirect pre-existing connection with that counterparty. Take for example an initial funding tree like this: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledgerL((L)) ledgerM((M)) ledgerR((R)) me((A)):::me hub1((I1)):::hub1 hub2((I2)):::hub2 counterparty((B)):::bob ETHAssetHolder-->|10|ledgerL; ETHAssetHolder-->|10|ledgerM; ETHAssetHolder-->|10|ledgerR; ledgerL-->|5|me; ledgerL-->|5|hub1; ledgerM-->|5|hub1; ledgerM-->|5|hub2; ledgerR-->|5|hub2; ledgerR-->|5|counterparty; classDef me fill:#4287f5 classDef hub1 fill:#85e69f classDef hub2 fill:#f242f5 classDef bob fill:#d93434 Here A wishes to enter a channel with B , but only has a ledger channel with I1 . However, since I1 has a ledger channel with I2 , and I2 has a ledger channel with B , it is indeed possible to safely fund such a channel in the following way. A proposes a channel V with participants A,I1,I2,B . Each participant has a numerical role in the virtual funding protocol. V allocates funds to A and B , but not to ther intermediaries I1,I2 . The other participants join the channel. See lifecycle of a channel . In each existing ledger channel ( L,M,R ), the participants of that channel make an update to include a guarantee for V in the outcome of the ledger channel. When all of the ledger channels (there will be 1 or 2) which an actor is participating in have reached consensus on guaranteeing V , that actor signs the postfund state for V . When the postfund round completes, the channel is considered funded. Here is an example of step 2 for M , the ledger channel between A and I1 : Typescript Go import { Exit , SingleAssetExit , NullAssetMetadata , } from \"@statechannels/exit-format\" ; const ethExit : SingleAssetExit = { asset : \"0x0\" , assetMetadata : NullAssetMetadata , allocations : [ { destination : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" , // Alice amount : \"0x04\" , // (1) allocationType : AllocationType.simple , metadata : \"0x\" , }, { destination : \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , // Bob amount : \"0x04\" , // (2) allocationType : AllocationType.simple , // a regular ETH transfer metadata : \"0x\" , }, { // (3) // The channel id of V: destination : \"0x0737369d5F8C4f161b949525D039038Da1EdBAC4\" , amount : \"0x02\" , allocationType : AllocationType.Guarantee , metadata : \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" , }, ], }; const exit = [ ethExit ]; This amount was decremented by 1. This amount was decremented by 1. This allocation was appended. Notice that it is a guarantee allocation. import ( \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/statechannels/go-nitro/channel/state/outcome\" \"github.com/statechannels/go-nitro/types\" ) var aliceDestination := types . Destination ( common . HexToHash ( \"0x00000000000000000000000096f7123E3A80C9813eF50213ADEd0e4511CB820f\" )) var I1Destination := types . Destination ( common . HexToHash ( \"0x0000000000000000000000000737369d5F8525D039038Da1EdBAC4C4f161b949\" )) var ethExit = outcome . SingleAssetExit { Allocations : outcome . Allocations { outcome . Allocation { Destination : aliceDestination , Amount : big . NewInt ( 4 ), // (1) }, outcome . Allocation { Destination : I1Destination , Amount : big . NewInt ( 4 ), // (2) }, outcome . Allocation { // (3) // The channel id of V: Destination : types . Destination ( common . HexToHash ( \"0x0737369d5F8C4f161b949525D039038Da1EdBAC4\" )), Amount : big . NewInt ( 2 ), Metadata : append ( aliceDestination . Bytes (), I1Destination . Bytes () ... ) }, }, } var exit = outcome . Exit {{ ethExit }} This amount was decremented by 1. This amount was decremented by 1. This allocation was appended. Notice that it is a guarantee allocation. Note how the additional allocation is a guarantee allocation. and has appropriately encoded metadata. If the ledger channels are labelled L_i and ordered left to right by participant role, the left metadata field in L_i 's guarantee is set to participant P_i 's destination and the right metadata field is set to participant P_(i+1) 's destiantion. And once steps 1-4 are complete, the funding graph looks like so: graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledgerL((L)) ledgerM((M)) ledgerR((R)) V((V)) me((A)):::me hub1((I1)):::hub1 hub2((I2)):::hub2 counterparty((B)):::bob ETHAssetHolder-->|10|ledgerL; ETHAssetHolder-->|10|ledgerM; ETHAssetHolder-->|10|ledgerR; ledgerL-->|4|me; ledgerL-->|4|hub1; ledgerM-->|4|hub1; ledgerM-->|4|hub2; ledgerR-->|4|hub2; ledgerR-->|4|counterparty; ledgerL-..->|2|V; ledgerM-..->|2|V; ledgerR-..->|2|V; classDef me fill:#4287f5 classDef hub1 fill:#85e69f classDef hub2 fill:#f242f5 classDef bob fill:#d93434 This construction generalizes, and works with anything from 1 , 2 (as shown here) or n hops. Channel V may be used for A to send payments to B , for example: see virtual payment app .","title":"Fund virtually"},{"location":"protocol-tutorial/0070-finalizing-a-channel/","text":"Finalizing a channel Finalization of a state channel is a necessary step before defunding it. It can happen on- or off-chain. Happy path In the so-called 'happy' case, all participants cooperate to achieve this. A participant wishing to end the state channel will sign a state with isFinal = true . Then, the other participants may support that state. Once a full set of n such signatures exists (this set is known as a finalization proof ) the channel is said to be 'closed' or 'finalized'. Off chain In most cases, the channel would be finalized and defunded off chain , and no contract calls are necessary. On chain -- calling conclude In the case where assets were deposited against the channel on chain (the case of direct funding), anyone in possession of a finalization proof may use it to finalize the outcome on-chain. They would do this by calling conclude on the adjudicator. This enables assets to be released . The conclude method allows anyone with sufficient off-chain state to immediately finalize an outcome for a channel without having to wait for a challenge to expire (more on that later). The off-chain state(s) is submitted (in an optimized format), and once relevant checks have passed, an expired challenge is stored against the channelId . (This is an implementation detail -- the important point is that the chain shows that the channel has been finalized.) TODO example Sad path When cooperation breaks down, it is possible to finalize a state channel without requiring on-demand cooperation of all n participants. This is the so-called 'sad' path to finalizing a channel, and it requires a supported (but not necessarily isFinal ) state(s) being submitted to the chain. The challenge function allows anyone holding the appropriate off-chain state(s) to register a challenge state on chain. It is designed to ensure that a state channel can progress or be finalized in the event of inactivity on behalf of a participant (e.g. the current mover). The required data for this method consists of a single state, along with n signatures. Once these are submitted (in an optimized format), and once relevant checks have passed, an outcome is registered against the channelId , with a finalization time set at some delay after the transaction is processed. This delay allows the challenge to be cleared by a timely and well-formed respond or checkpoint transaction. We'll get to those shortly. If no such transaction is forthcoming, the challenge will time out, allowing the outcome registered to be finalized. A finalized outcome can then be used to extract funds from the channel (more on that below, too). TODO example Tip The challengeDuration is a fixed parameter expressed in seconds, that is set when a channel is proposed. It should be set to a value low enough that participants may close a channel in a reasonable amount of time in the case that a counterparty becomes unresponsive; but high enough that malicious challenges can be detected and responded to without placing unreasonable liveness requirements on responders. A challengeDuration of 1 day is a reasonable starting point, but the \"right\" value will likely depend on your application. Call challenge TODO example Note The challenger needs to sign this data: keccak256(abi.encode(challengeStateHash, 'forceMove')) in order to form challengerSig . This signals their intent to challenge this channel with this particular state. This mechanism allows the challenge to be authorized only by a channel participant. We provide a handy utility function signChallengeMessage to form this signature. A challenge being registered does not mean that the channel will inexorably finalize. Participants have the timeout period in order to be able to respond. Perhaps they come back online after a brief spell of inactivity, or perhaps the challenger was trying to (maliciously) finalize the channel with a supported but outdated (or 'stale') state. Clear a challenge Call checkpoint The checkpoint method allows anyone with a supported off-chain state to establish a new and higher turnNumRecord on chain, and leave the resulting channel in the \"Open\" mode. It can be used to clear a challenge. Call challenge again It is important to understand that a challenge may be \"cleared\" by another more recent challenge. The channel will be left in challenge mode (so it has not really been 'cleared' in that sense), but some on chain storage will be updated, such as the deadline for responding. Extract info from Adjudicator Events You may have noticed that to respond, the challenge state itself must be (re)submitted to the chain. To save gas, information is only stored on chain in a hashed format. Clients should, therefore, cache information emitted in Events emitted by the adjudicator, in order to be able to respond to challenges.","title":"Finalizing a channel"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#finalizing-a-channel","text":"Finalization of a state channel is a necessary step before defunding it. It can happen on- or off-chain.","title":"Finalizing a channel"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#happy-path","text":"In the so-called 'happy' case, all participants cooperate to achieve this. A participant wishing to end the state channel will sign a state with isFinal = true . Then, the other participants may support that state. Once a full set of n such signatures exists (this set is known as a finalization proof ) the channel is said to be 'closed' or 'finalized'.","title":"Happy path"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#off-chain","text":"In most cases, the channel would be finalized and defunded off chain , and no contract calls are necessary.","title":"Off chain"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#on-chain-calling-conclude","text":"In the case where assets were deposited against the channel on chain (the case of direct funding), anyone in possession of a finalization proof may use it to finalize the outcome on-chain. They would do this by calling conclude on the adjudicator. This enables assets to be released . The conclude method allows anyone with sufficient off-chain state to immediately finalize an outcome for a channel without having to wait for a challenge to expire (more on that later). The off-chain state(s) is submitted (in an optimized format), and once relevant checks have passed, an expired challenge is stored against the channelId . (This is an implementation detail -- the important point is that the chain shows that the channel has been finalized.) TODO example","title":"On chain -- calling conclude"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#sad-path","text":"When cooperation breaks down, it is possible to finalize a state channel without requiring on-demand cooperation of all n participants. This is the so-called 'sad' path to finalizing a channel, and it requires a supported (but not necessarily isFinal ) state(s) being submitted to the chain. The challenge function allows anyone holding the appropriate off-chain state(s) to register a challenge state on chain. It is designed to ensure that a state channel can progress or be finalized in the event of inactivity on behalf of a participant (e.g. the current mover). The required data for this method consists of a single state, along with n signatures. Once these are submitted (in an optimized format), and once relevant checks have passed, an outcome is registered against the channelId , with a finalization time set at some delay after the transaction is processed. This delay allows the challenge to be cleared by a timely and well-formed respond or checkpoint transaction. We'll get to those shortly. If no such transaction is forthcoming, the challenge will time out, allowing the outcome registered to be finalized. A finalized outcome can then be used to extract funds from the channel (more on that below, too). TODO example Tip The challengeDuration is a fixed parameter expressed in seconds, that is set when a channel is proposed. It should be set to a value low enough that participants may close a channel in a reasonable amount of time in the case that a counterparty becomes unresponsive; but high enough that malicious challenges can be detected and responded to without placing unreasonable liveness requirements on responders. A challengeDuration of 1 day is a reasonable starting point, but the \"right\" value will likely depend on your application.","title":"Sad path"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#call-challenge","text":"TODO example Note The challenger needs to sign this data: keccak256(abi.encode(challengeStateHash, 'forceMove')) in order to form challengerSig . This signals their intent to challenge this channel with this particular state. This mechanism allows the challenge to be authorized only by a channel participant. We provide a handy utility function signChallengeMessage to form this signature. A challenge being registered does not mean that the channel will inexorably finalize. Participants have the timeout period in order to be able to respond. Perhaps they come back online after a brief spell of inactivity, or perhaps the challenger was trying to (maliciously) finalize the channel with a supported but outdated (or 'stale') state.","title":"Call challenge"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#clear-a-challenge","text":"","title":"Clear a challenge"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#call-checkpoint","text":"The checkpoint method allows anyone with a supported off-chain state to establish a new and higher turnNumRecord on chain, and leave the resulting channel in the \"Open\" mode. It can be used to clear a challenge.","title":"Call checkpoint"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#call-challenge-again","text":"It is important to understand that a challenge may be \"cleared\" by another more recent challenge. The channel will be left in challenge mode (so it has not really been 'cleared' in that sense), but some on chain storage will be updated, such as the deadline for responding.","title":"Call challenge again"},{"location":"protocol-tutorial/0070-finalizing-a-channel/#extract-info-from-adjudicator-events","text":"You may have noticed that to respond, the challenge state itself must be (re)submitted to the chain. To save gas, information is only stored on chain in a hashed format. Clients should, therefore, cache information emitted in Events emitted by the adjudicator, in order to be able to respond to challenges.","title":"Extract info from Adjudicator Events"},{"location":"protocol-tutorial/0080-defunding-a-channel/","text":"Defunding a channel Defunding can only happen after a channel finalizes . Broadly speaking, it is the inverse of channel funding : it can therefore happen on- or off-chain. On-chain defunding using transfer If the channel is funded on-chain, it can be defunded using the transfer method. It must first be finalized on chain , via either a happy or sad path. Because of the information is stored on chain , it is necesary to supply both the stateHash and encoded outcome of the channel when calling transfer . Furthermore, an asset index is required for slicing the outcome into a single asset outcome, as well as a list of indices to \"target\". import { BigNumber , ethers } from \"ethers\" ; import { encodeAllocation , MAGIC_ADDRESS_INDICATING_ETH , } from \"@statechannels/nitro-protocol\" ; const amount = \"0x03\" ; const EOA = ethers . Wallet . createRandom (). address ; const destination = hexZeroPad ( EOA , 32 ); const assetOutcome : AllocationAssetOutcome = { asset : MAGIC_ADDRESS_INDICATING_ETH , allocationItems : [{ destination , amount }], }; const outcomeBytes = encodeOutcome ([ { asset : MAGIC_ADDRESS_INDICATING_ETH , allocationItems : allocation }, ]); const assetIndex = 0 ; // (1) const stateHash = constants . HashZero ; // (2) const indices = []; // (3) const tx2 = NitroAdjudicator . transfer ( assetIndex , channelId , outcomeBytes , stateHash , indices ); This implies we are paying out the 0th asset (in this case the only asset, ETH) If the channel was concluded on the happy path, we can use this default value This magic value (a zero length array) implies we want to pay out all of the allocationItems (in this case there is only one) Visually, we can see some of the on-chain funding for the channel has been transferred directly to one the channel's participants: Before After graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|5|me; ledger-->|5|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) me(( )):::me hub(( )):::hub ETHAssetHolder-->|5|me; ETHAssetHolder-->|5|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 Info There is a convenience method concludeAndTransferAllAssets which combines concluding with transferring for every asset -- batching them to save gas. Tracking on-chain storage When a channel has been partially defunded using transfer , the on-chain storage is updated. To continue the defunding process, it is necessary to track sufficient information to supply the new outcome for the next call to transfer (which could be made by a different party). To do this, it is necessary to listen for AllocationUpdated events and to compute the new outcome using computeTransferEffectsAndInteractions off-chain helper function Off-chain defunding If the channel in question is funded off chain, it can usually be cooperatively defunded. If that fails, the channel must be finalized on chain and then defunded using the on-chain transfer or reclaim methods. Cooperate Here, participants in the parent channel make an update which reverses (or reverts) the update they made when funding the channel . This involves: Removing the allocation which targets the channel in question. Appropriately incrementing the allocations to the parent channel's participants' external destinations. For step 2, this is very simple if the channel in question was funded with a simple allocation . Each participant in the parent channel is awarded the funds which were allocated to them in the child channel. If the channel in question was virtually funded with a guarantee , each participant in the parent channel is awarded the funds which were allocated to a possibly-distinct participant in the child channel, according to the mapping encoded in the guarantee metadata. The operation should mirror the on-chain reclaim method. Transfer in, transfer out If cooperation is not possible, the parent and child channels (let's call them L and X respectively) must both be finalized on chain. If the child channel is funded with a simple allocation like so: funds may be transferred from the parent channel in to the child channel. Now the child channel is funded on chain. It can now be defunded as above by transferring money out of X . Visually, the following transformation has been applied: Before After graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ledger-->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ETHAssetHolder-->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 Reclaim and transfer out If cooperation is not possible, the parent and child channels must both be finalized on chain. If the child channel is funded with a guarantee , funds may be transferred from the child channel to the parent channel using reclaim . Next, the parent channel may be defunded as above . Visually, the following transformation has been applied: Before After graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ledger-.->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|6|me; ledger-->|4|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434","title":"Defunding a channel"},{"location":"protocol-tutorial/0080-defunding-a-channel/#defunding-a-channel","text":"Defunding can only happen after a channel finalizes . Broadly speaking, it is the inverse of channel funding : it can therefore happen on- or off-chain.","title":"Defunding a channel"},{"location":"protocol-tutorial/0080-defunding-a-channel/#on-chain-defunding-using-transfer","text":"If the channel is funded on-chain, it can be defunded using the transfer method. It must first be finalized on chain , via either a happy or sad path. Because of the information is stored on chain , it is necesary to supply both the stateHash and encoded outcome of the channel when calling transfer . Furthermore, an asset index is required for slicing the outcome into a single asset outcome, as well as a list of indices to \"target\". import { BigNumber , ethers } from \"ethers\" ; import { encodeAllocation , MAGIC_ADDRESS_INDICATING_ETH , } from \"@statechannels/nitro-protocol\" ; const amount = \"0x03\" ; const EOA = ethers . Wallet . createRandom (). address ; const destination = hexZeroPad ( EOA , 32 ); const assetOutcome : AllocationAssetOutcome = { asset : MAGIC_ADDRESS_INDICATING_ETH , allocationItems : [{ destination , amount }], }; const outcomeBytes = encodeOutcome ([ { asset : MAGIC_ADDRESS_INDICATING_ETH , allocationItems : allocation }, ]); const assetIndex = 0 ; // (1) const stateHash = constants . HashZero ; // (2) const indices = []; // (3) const tx2 = NitroAdjudicator . transfer ( assetIndex , channelId , outcomeBytes , stateHash , indices ); This implies we are paying out the 0th asset (in this case the only asset, ETH) If the channel was concluded on the happy path, we can use this default value This magic value (a zero length array) implies we want to pay out all of the allocationItems (in this case there is only one) Visually, we can see some of the on-chain funding for the channel has been transferred directly to one the channel's participants: Before After graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|5|me; ledger-->|5|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) me(( )):::me hub(( )):::hub ETHAssetHolder-->|5|me; ETHAssetHolder-->|5|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 Info There is a convenience method concludeAndTransferAllAssets which combines concluding with transferring for every asset -- batching them to save gas.","title":"On-chain defunding using transfer"},{"location":"protocol-tutorial/0080-defunding-a-channel/#tracking-on-chain-storage","text":"When a channel has been partially defunded using transfer , the on-chain storage is updated. To continue the defunding process, it is necessary to track sufficient information to supply the new outcome for the next call to transfer (which could be made by a different party). To do this, it is necessary to listen for AllocationUpdated events and to compute the new outcome using computeTransferEffectsAndInteractions off-chain helper function","title":"Tracking on-chain storage"},{"location":"protocol-tutorial/0080-defunding-a-channel/#off-chain-defunding","text":"If the channel in question is funded off chain, it can usually be cooperatively defunded. If that fails, the channel must be finalized on chain and then defunded using the on-chain transfer or reclaim methods.","title":"Off-chain defunding"},{"location":"protocol-tutorial/0080-defunding-a-channel/#cooperate","text":"Here, participants in the parent channel make an update which reverses (or reverts) the update they made when funding the channel . This involves: Removing the allocation which targets the channel in question. Appropriately incrementing the allocations to the parent channel's participants' external destinations. For step 2, this is very simple if the channel in question was funded with a simple allocation . Each participant in the parent channel is awarded the funds which were allocated to them in the child channel. If the channel in question was virtually funded with a guarantee , each participant in the parent channel is awarded the funds which were allocated to a possibly-distinct participant in the child channel, according to the mapping encoded in the guarantee metadata. The operation should mirror the on-chain reclaim method.","title":"Cooperate"},{"location":"protocol-tutorial/0080-defunding-a-channel/#transfer-in-transfer-out","text":"If cooperation is not possible, the parent and child channels (let's call them L and X respectively) must both be finalized on chain. If the child channel is funded with a simple allocation like so: funds may be transferred from the parent channel in to the child channel. Now the child channel is funded on chain. It can now be defunded as above by transferring money out of X . Visually, the following transformation has been applied: Before After graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ledger-->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ETHAssetHolder-->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434","title":"Transfer in, transfer out"},{"location":"protocol-tutorial/0080-defunding-a-channel/#reclaim-and-transfer-out","text":"If cooperation is not possible, the parent and child channels must both be finalized on chain. If the child channel is funded with a guarantee , funds may be transferred from the child channel to the parent channel using reclaim . Next, the parent channel may be defunded as above . Visually, the following transformation has been applied: Before After graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) channel((X)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|2|me; ledger-->|2|hub; ledger-.->|6|channel; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434 graph TD; linkStyle default interpolate basis; ETHAssetHolder( ) ledger((L)) me(( )):::me hub(( )):::hub ETHAssetHolder-->|10|ledger; ledger-->|6|me; ledger-->|4|hub; classDef me fill:#4287f5 classDef hub fill:#85e69f classDef bob fill:#d93434","title":"Reclaim and transfer out"}]}